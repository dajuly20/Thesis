\section{Umsetzung}\label{kap:ums}

\todo{Struktur Umsetzung einfügen }

\subsection{Parsen von Logikausdrücken}\label{kap:ums:parsing}
Das Ziel dieses Projektes ist es, dass die Ausgänge der Steuerung in Abhängigkeit von Eingängen wie physikalischen Eigängen oder zum Beispiel Timer-bausteinen ein beziehungsweise ausgeschaltet werden. Dafür ist in einer Textdatei für jeden Ausgang eine Zeile vorgesehen. Eine Zeile beginnt hierbei mit dem zu definierenden Ausgang, also zum Beispiel Ho1, worauf ein Gleichheitszeichen zu folgen hat. Der gesamte Ausdruck hinter dem Gleichheitszeichen wird zur Laufzeit des Programms durchlaufen, wobei jedes vorkommende Paar von [ und ] durch eine Null oder eine Eins ersetzt. Innerhalb der Klammern, findet sich gleich genau wie bei dem Bezeichner vor dem Gleichheitszeichen, die jeweilige Bezeichnung der Abhängigkeit. Lautet die Zeile also etwa Ho0= [Hi0] \& [Hi1] so wird die Komplette erste Klammer durch den Wert von Hi0 ersetzt, wärend die zweite Klammer  durch den Wert von Hi1 ersetzt wird. Daraus ergibt sich dann, vorausgesetzt Hi0 und Hi1 sind im Zustand \chphl{Ein}, Ho0= 1 \& 1. Das für den Leser offensichtliche Ergebnis dieser Gleichung ist 1 oder \chphl{true}. Jedoch gestaltet sich eine programmatische Lösung des Problems als deutlich komplexer. Denn sobald mehr als drei Ausdrücke im Spiel sind, müssen wie bei klassischer Mathematik Rechenregeln befolgt werden. Punkt vor Strich sowie die Beachtung von Klammern. Dabei kann ein Ausdruck beliebig Komplex sein. Eine Rechersche nach Ansätzen führte zu Stackoverflow. (Siehe  
\footnote{Abr. 11.03.2019 \url{https://stackoverflow.com/questions/8706356/boolean-expression-grammar-parser-in-c/8707598\#8707598}}
 und  \footnote{Abr. 11.03.2019 \url{http://coliru.stacked-crooked.com/a/c40382620fb75b75}}) Dieser Ansatz löste genau das Problem und wurde somit in das Projekt übernommen. 
%
\subsection{Automatische Prüfung von Abhängigkeiten}\label{kap:ums:abh}
Ein Problem was sich mit dem Einbinden der Lösung zum Parsen der Logikausdrücke ergab, war die Abhängigkeit zu Boost. Auf dem Desktop Computer auf dem die Lösung getestet wurde, konnte das Projekt dank installiertem boost Paket ohne Probleme übersetetzt werden. Da es sich bei dem  Zielsystem jedoch um eine ARM Architektur handelt, musste der code dort Übersetzt werden. In den Paketquellen des dort installieren Raspian, ist jedoch eine ältere Version des Boost Pakets hinterlegt, was dazu führt dass Boost manuell heruntergeladen und gebaut werden muss. Obwohl sich dieses Problem im Laufe der Zeit durch aktualisierung des Paketes in den Paketquellen von Raspian von selbst lösen wird, muss dennoch geprüft werden ob die installierte Version den Ansprüchen genügt. Hierfür wurde ein Bash script erstellt, welches auch alle weiteren abhängigkeiten Prüft und gegebenenfalls installiert. Dazu zählen auch die in *REF* erwähnten Bibliotheken um die Hardware anzusprechen und wie in *REF* erwähnt der verwendete Kompiler. 
 
\subsection{Benamungsschnema}\label{kap:ums:banamsung}
Nachdem die Auswertung beziehungsweise das Parsing der Logikausdrücke funktionierte, sollte auch die Auswertung der Bezeichner automatisiert werden. Ein Benamsungsschema wurde dabei schon vorher erdacht. Es besteht aus einem führenden Großbuchstaben, gefolgt von einem Kleinbuchstaben und einer Zahl. Dabei wird der führende Buchstabe als Kanal bezeichnet, der zweite als Entität und die Ziffer als Pin-Nummer. So könnte zum Beispiel der Buchstabe \chphl{H} den Kanal Hardware beschreiben, welcher  wiederrum die Entitäten \chphl{i} für Input und \chphl{o} besitzt, welche jeweils ein Byte, also 8 Bits oder Pins haben. 

\subsection{Klassenstrukrur und Kanäle}\label{kap:ums:klassen}
Im Programm werden die zuvor beschriebenen Kanäle von einem Abkömmling der Basisklasse \chphl{IO\_Channel} (siehe Abb. \ref{img:classIOChannel}) repräsentiert. Wobei jeder Kanal als Eigenschaft eine Map mit Entitäten führt, welche durch Objekte des Typs \chphl{Channel\_Entity} (siehe Abb. \ref{img:classChannelEntity}) repräsentiert werden. Eine Entität wiederum weiß, wie groß ihre Breite ist, also wie viele Bits sie hat und ob sie nur lesbar oder auch beschreibbar ist. Eine weitere Klasse \chphl{IO\_Channel\_AccessWrapper} (siehe Abb. \ref{img:classAgregation}) bündelt alle vorhandenen Kanäle inklusive der jeweiligen Entitäten. Zudem erleichtert Sie mittels Überladung der Array-Operatoren den Zugriff. Ein Zugriff ist dann wie in Listing \ref{code:chnlAccess} gezeigt wird möglich. Dazu müssen die Entsprechenden Kanäle vorher wie in Listing \ref{code:chlnInit} zu sehen initialisiert und einer Instanz der Klasse \chphl{IO\_Channel\_AccessWrapper} übergeben werden. Der für den späteren Zugriff auf den Kanal nötige Buchstabe, wird in diesem Zuge festgelegt, während die Buchstaben der untergeordneten Entitäten Bestandteil des jeweiligen Kanals sind und dementsprechend dort definiert werden. 


\begin{listing}[H]
	\inputminted[numbersep=1pt,fontsize=\scriptsize,frame=single, firstline=364,lastline=369]{c}{./code/main-klassenstruktur.cpp}
	\caption{Initialisieren der Kanäle und Entitäten}
	\label{code:chlnInit}
\end{listing}


\begin{listing}[H]
	\inputminted[numbersep=1pt,fontsize=\scriptsize,frame=single, firstline=415,lastline=416]{c}{./code/main-klassenstruktur.cpp}
	\caption{Zugriff auf Kanal und Entität exemplarisch}
	\label{code:chnlAccess}
\end{listing}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.95\textwidth ,clip]{./code/Aggregation.pdf}
		\caption{Klassendiagramm Aggregation der Klassen}
		\label{img:classAgregation}
	\end{center} 
\end{figure}	
Zu sehen ist die Aggregation zwischen dem \chphl{IO\_Channel\_AccessWrapper} den Kanälen \chphl{IO\_Channel} und den Entitäten \chphl{Channel\_Entity}. Alle Kanäle werden von dem  \chphl{IO\_Channel\_AccessWrapper} zusammengefasst. Ein Zugriff erfolgt ausschließlich über diesen Weg. 


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.95\textwidth ,clip]{./code/IOChannel.pdf}
		\caption{Vererbungshierarchie der Basisklasse IOChannel}
		\label{img:classIOChannel}
	\end{center} 
\end{figure}	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.95\textwidth ,clip]{./code/ChannelEntity.pdf}
		\caption{Vererbungshierarchie der Basisklasse ChannelEntity}
		\label{img:classChannelEntity}
	\end{center} 
\end{figure}	

Die Entitäten erben von der Basisklasse Entity. Sie überschreiben Methoden um lesend oder schreibend, entweder auf den gesamten Inhalt auf einmal oder Bitweise auf den Inhalt zuzugreifen. Dafür sind die Methoden read\_pin, write\_pin beziehungsweise read\_all und write\_all vorgesehen. 



\subsubsection{Hardware Kanäle}\label{kap:ums:hwchannels}
Der Wohl wichtigste Kanal ist der Hardware Kanal. Die Klassenstruktur in Abb. \ref{img:classIOChannel} zeigt, dass alle Kanäle eine gemeinsame Basisklasse haben. Der Hardware Kanal ist eine Spezialisierung der Basisklasse, welche spezifische Funktionen für die Entsprechende Hardware beherbergt. So finden sich hier Methoden zur Steuerung des Caching sowie ein blockierender Aufruf, welcher auf einen Interrput an der Hardware reagiert. Die Funktionen für den schreibenden und lesenden Zugriff auf die Ein- und Ausgänge der Hardware, sind in Entitäten gekapselt. Für eben jenen Zweck existieren zwei Spezialisierungen der \chphl{Channel\_Entity} (siehe Abb. \ref{img:classChannelEntity}) Basisklasse, welche für den Zugriff mit \chphl{i} für den Eingang (input) beziehungsweise \chphl{o} für den Ausgang (output) referenziert werden.   

\subsubsection{Merker Bausteine}\label{kap:ums:memorychannel}
Die erste Erweiterung, welche wie in Abb. \ref{code:chlnInit} zu sehen mit dem Buchstaben M referenziert wird, sind Memory Bausteine. Da ein Memory Baustein nicht richtungsorientiert sind, das heißt es existiert keine Eingangs oder Ausgangsgröße, wurde hier vom Benamsungsschema für Entitäten  abgewichen. Eine Referenzierung ist hier mittels eines oder mehrerer Buchstaben geplant. Somit bietet ein Merker Baustein Platz für 8 Zustandswerte pro verwendeter Entität. Bislang ist lediglich die Entität \chphl{a} angelegt, wobei geplant ist die Anzahl an Buchstaben beziehungsweise Entitäten durch einen Konstruktorparameter nach Außen zu führen, womit die Anzahl wie in Abb. \ref{code:chlnInit} zu sehen beim Einfügen bestimmt werden könnte, oder in einem weiteren Schritt in eine Konfigurationsdatei exportiert werden kann. 

\subsubsection{Timer Bausteine}\label{kap:ums:timerchannel}
Timer Bausteine waren die wohl komplexesten Bausteine. Eine Verzögerung im Programmablauf bedeutet entweder ein blockieren, was aber bedeuten würde, dass das Programm in dieser Zeit auch nichts anderes tun kann und somit nicht auf Ereignisse reagieren kann. Die andere alternative ist Multithreading, also das Einführen von Parallelen Handlungssträngen, welche weitere Probleme bringen. So muss zum Beispiel beim Zugriff auf gemeinsam genutzte Ressourcen dafür sorge getragen werden, dass nicht gelesen wird während gerade geschrieben wird. Des weiteren musste die Hauptschleife überarbeitet werden. Bislang wurde die Programmlogik bei jedem eintreten eines Hardware-Ereignisses genau einmal durchlaufen. Jedoch muss die Programmlogik nun auch durch Ablauf eines Timers erneut durchlaufen werden. Gelöst wurde dies mithilfe einer Binären Variable als Schalter, welche zusammen mit eines Mutex zur Vermeidung von gleichzeitigem Zugriff, und einer Condition Variable zur Benachrichtigung des Hauptprozesses, in die Klasse \chphl{iterationSwitchGuard} gekapselt wurde. 
Ein Timerbaustein (mehrere sind Theoretisch möglich), bietet 8 Konfigurierbare Timer. Dabei gibts es eine Entität um einen Timer auszulösen \chphl{t} (Trigger) und eine Entität, welcher als Ausgang fungiert \chphl{o} (Output). So ergibt sich in der Programmlogik die selbe Syntax, welche sich auch bei Hardwarekanälen bietet: Ein explarisches triggern des Timers 3 würde erfolgen, indem eine Zeile der Logikdatei mit \chphl{Tt3=} beginnt. Eine Verwendung des Ausgangswertes desselben Timers, würde durch integrieren des Bezeichners \chphl{[To3]} in die Logikzuweisung eines anderen Bezeichners erfolgen. Die Parametrisierung des Timers erfolgt durch einbinden einer Konfigurationsdatei (siehe Listing \ref{code:timersConf}) hierbei lassen sich für jeden Timer eine Einschaltverzögerung sowie eine Ausschaltverzögerung definiert werden. Jeder Wert ungleich null bewirkt eine Verzögerung, eine gleichzeitige Nutzung von Ein und Ausschaltverzögerung ist möglich. Werte gleich null bewirken eine sofortige Änderung am Ausgang, sobald sich der Eingangswert verändert. Beim Einlesen der Konfiguarionsdatei werden sämtliche Leerzeichen entfernt. Zudem kann mit einem Semikolon \chphl{;} oder einer Raute \chphl{\#} ein Kommentar eingeleitet werden, welches alle restlichen Zeichen der Zeile beim Einlesen entfernt. Die Verzögerungszeiten sind in Millisekunden anzugeben, wobei die Reihenfolge der nicht sukzessive erfolgen muss. Der Maximalwert beläuft sich auf 4.294.967.295, was die größte in unsignes long darstellbare Zahl ist und umgerechnet etwa 49 Tagen entspricht. 
\begin{listing}[H]
	\inputminted[numbersep=1pt,fontsize=\scriptsize,frame=single, firstline=14,lastline=25]{c}{./code/timers.conf}
	\caption{Beispiel der Timer Konfigurationsdatei}
	\label{code:timersConf}
\end{listing}


\subsubsection{Virtuelle Kanäle}\label{kap:ums:virtualchannel}
Virtuelle Kanäle sind ein Konzept dass die Kommunikation der Steuerung mit entfernten Endpunkten ermöglichen. Ein Virtueller Kanal ist hierbei lediglich ein veränderter Memory Baustein, welcher entgegen entgegen anders als ein normaler Memory Baustein wieder richtungsorientiert ist. Das heißt es gibt eine Eingangs-Entität und eine Ausgangs-Entität. Hierbei muss beachtet werden, dass die Perspektive so gesetzt ist, dass ein Eingang die extern empfangenen Daten beinhaltet. Während in den Ausgang geschrieben wird. Die Gegenseite bildet der in *REF* beschriebene WebSocket Server, beziehungsweise was auch immer die Gegenseite bildet. Das kann das WebFrontend *REF* dieses Projektes sein, oder auch jeder andere WebSocket fähige Client. Angedacht ist auch die Implementierung eines WebSocket Clients in das Backend, womit sich zwei Einheiten verbinden ließen. 


\subsection{Laden der Programmlogik aus Datei}\label{kap:ums:logicOutsource}
Das Logikprogramm wurde im nächsten Schritt in eine Textdatei ausgelagert. Sie soll künftig von der grafischen Benutzeroberfläche automatisch erstellt werden können, kann aber nach wie vor auch von Hand erstellt werden. Die Datei enthält einen Ausgang pro Zeile, gefolgt von einem Gleichheitszeichen und den Abhängigkeiten. Zeichen die auf ein Semikolon folgen, werden dabei als Kommentar gewertet und ausgelassen. Sie wird bei Programmstart eingelesen und verbleibt dann im Speicher. Zum Speichern der Daten wird ein \chphl{Vector} benutzt, welcher für jede Zeile der Logikdatei einen weiteren Eintrag erhält. Da vor einem Gleichheitszeichen lediglich ein Ausgang stehen darf (z.B. \ref{softLogic} Zeile 1: \chphl{Ho0}), ist somit jeder Eintrag des Vectors die Definition genau einer Abgeschlossenen Zuweisung. Bei Mehrfacher Definition eines Ausgangs, überschreibt die spätere Definition die vorangegangene. 

\begin{listing}[H]
	\inputminted[numbersep=1pt,fontsize=\scriptsize,frame=single, firstline=29,lastline=36]{c}{./code/logic.conf}
	\caption{Beispiel der Programmlogik Datei}
	\label{code:softLogic}
\end{listing}


\subsubsection{Erneutes Laden der Logik zur Laufzeit}\label{kap:ums:reloadConf}
Zum erneuten einlesen der Logik, wurde ein Signalhandler vorgesehen, welcher auf das Signal SIGUSR1 hört. Die entsprechende Funktion ließt dann die Logikdaten erneut ein und überschreibt damit die vorherige Version im Speicher. Damit muss die Steuerung nicht neu gestartet werden und ermöglicht das Steuerungsprogramm zur Laufzeit zu verändern.


\subsection{Hauptschleife und Iterationslogik}\label{kap:ums:mainloop}
Das Logikprogramm liegt nun im Speicher und das Programm betritt die Hauptschleife. Doch treibt ein einfaches polling die Auslastung des Prozessors unnötig nach oben. Nun könnte nach jedem Durchlauf eine gewisse Zeit gewartet werden, bevor eine neue beginnt. Doch das verringert die Reaktionszeit der Steuerung. Die beste Lösung findet sich direkt im Treiber des PiFaceDigital. Hier bietet sich eine Funktion, die bis zum Eintreten einer Veränderung der  Eingangswerte blockiert. Intern Eingesetzt wird hier ein Epoll, welcher einen File descriptor auf einen der GPIOs des Raspberry Pi überwacht und diesen somit als Interrupt Kanal nutzt. 


\subsection{Logik Prozessor}\label{kap:ums:logicProcessor}
Den Kern des Projektes bildet der in \autoref{code:logicEngine} gezeigte Logikprozessor. Es ist eine Methode, welche den in \autoref{kap:ums:logicOutsource} geladenen Logik-Vektor zeilenweise durchläuft. Im ersten Schritt wird die Zeile nun auf Vorhandensein eines Gleichheitszeichens hin überprüft (\autoref{code:logicEngine} Zeile \ref{codeline:split}). Eine Zeile ohne Gleichheitszeichen wird hierbei schlicht verworfen. Andernfalls wird zunächst der Teil vor dem Gleichheitszeichen näher untersucht. Dabei wird sichergestellt dass der Bezeichner aus drei Zeichen besteht, wobei die ersten beiden alphabetisch und der letzte numerisch sein muss. Diese drei Teile werden dann (Zeile \ref{codeline:charSeperateBegin}-\ref{codeline:charSeperateEnd}) für die weitere Verarbeitung gespeichert. Der fertig ausgewertete Teil nach dem Gleichheitszeichen, auf dessen Verarbeitung nachfolgend noch etwas genauer eingegangen wird und der nunmehr entweder \texttt{0} oder \texttt{1} ist, wird dem entsprechenden Kanal nun zugewiesen. Wie in \autoref{code:logicEngine} Zeile \ref{codeline:equation} zu sehen, wird nun eine Instanz \texttt{chnl} der Klasse \texttt{IO\_Channel\_AccessWrapper} für den eigentlichen Zugriff auf die Ressource verwendet. Zuvor müssen jedoch die vorher gespeicherten Teile des Bezeichners eingefügt werden verwendet. (Siehe \autoref{kap:ums:klassen}\chphl{ \nameref{kap:ums:klassen}}). 
Zudem wird dem Bezeichner in diesem Zuge ein Wert zugewiesen. Um diesen zu erhalten muss nun die Gleichung gelöst werden. Diese beinhaltet ebenfalls Bezeichner, welche vom Funktor \texttt{replaceIdentifier} durch dessen aktuellen Wert ersetzt wird. Zurück gegeben wird ein String, welcher nun nur noch aus Binärzahlen, arithmetischen Operatoren (\& für und bzw. | für oder) und Klammern besteht. Die eigentliche Lösung der Gleichung erfolgt dann mittels eines Funktionsaufrufes auf einen in Boost Spirit geschriebenen Parser (siehe Unterabschnitt \chpref{kap:ums:parsing}). 
\begin{listing}[H]

	\inputminted[numbersep=1pt,linenos=true, mathescape, numbers=left, fontsize=\scriptsize,frame=single, firstline=186,lastline=222]{c}{./code/main-klassenstruktur.cpp}
	\caption{Logik Engine}
	\label{code:logicEngine}
\end{listing}
\subsection{WebSocket Server}
\subsection{Benutzeroberfläche}
\todo{Grafik Erstellen}
\subsubsection{Übersicht Komponenten}
Die eigentliche Anwendung ist Hauptsächlich in HTML und JavaScript und wird im Browser des Benutzers ausgeführt. Um die Benutzeroberfläche mit dem Rest der Anwendung kommunizieren zu lassen, bedarf es mehrerer Komponenten. Obwohl der Hauptteil der Anwendung über JavaScript Websockets eine direkte Verbindung vom Browser zum Backend herstellt, wird als direkte Schnittstelle zum Browser ein Apache2 Webserver eingesetzt. Dieser wird um das Proxy-Modul modproxy erweitert was es ermöglicht an das Backend gerichtete Anfragen mit dem WebSocket Header auf die lokale loopback Adresse \texttt{127.0.0.1} weiterzuleiten, während alle sonstigen Anfragen vom Webserver direkt beantwortet werden können. Zum einen wird hierdurhc die Konfiguration von Verschlüsselten Verbindungen über SSL und den Abruf der dazu nötigen Zertifikate erheblich vereinfacht, denn einige Zertifizierungs-Anbieter wie zum Beispiel Let's Encrypt *REF* bieten extra auf Apache zugeschnittene Scripte, die ebendies fast vollständig Automatisieren. Zum anderen ist es so möglich die Auslieferung der HTML und JavaScript Quellen an den Webserver zu delegieren, anstatt bei einer eigenen Implementierung Sicherheitslücken und Performance-Probleme zu riskieren. Weiterhin ermöglicht es dieser Ansatz auch PHP Scripte zu verarbeiten, dies wird zum Beispiel eingesetzt um Konfigurationsdateien vom Browser auf dem Server abzulegen, oder durch dem Backend Signale zu senden wenn es die Logikdatei erneut einlesen soll.
\subsubsection{Apache Webserver}
\subsubsection{JavaScript Anwendung}
\subsubsection{Logik Editor CircuitVerse}
Die Wahl für einen Graphischen Logikeditor fiel auf den mit der MIT Lizenz gekennzeichneten Editor CircuitVerse *REF*. Die Lizenzierung gestattet es, das Programm zu verändern und weiter zu verbreiten. Der in \autoref{img:circuitVerseBasic} gezeigte Screenshot, zeigt den Aufbau des Editors. Im linken Abschnitt kann dabei zwischen verschiedenen Bauteilen gewählt werden, welche dann per Drag \& Drop auf die rechts daneben befindliche Zeichenfläche gezogen werden können. Grüne Punkte kennzeichnen dabei die Anschlussknoten, welche dann wiederum durch ziehen mit gehaltener linker Maustaste miteinander verbunden werden können. CircuitVerse bietet überdies die Möglichkeit, die erstellte Zeichnung in einem eigenen Format zu  speichern, sowie sie als Grafik zu exportieren. Des weiteren gibt es die Möglichkeit eine Zeichnung anhand einer Logiktabelle automatisch erstellen zu lassen. 

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.65\textwidth ,clip]{./images/circuitverse.jpg}
		\caption{Screenshot einer Logikschaltung in CircuitVerse}
		\label{img:circuitVerseBasic}
	\end{center} 
\end{figure}	

 Eine Erweiterung von CircuitVerse ist nötig, um die gezeichnete Logikschaltung in ein Format umwandeln zu können, welches vom Backend verstanden wird. Weiterhin muss das Benamsungsschema (siehe \chpref{kap:ums:banamsung}) eingebracht werden. Letztlich muss auch die Bauteile-Auswahl auf jene Bauteile reduziert werden, welche auch tatsächlich in der Steuerung verfügbar sind. \chpref{kap:ums:logicOutsource} beschriebt das Format der Datei, die letztlich aus einer gezeichneten Logikschaltung gewonnen werden soll. CircuitVerse verwendet für die Speicherung der Schaltung eine JSON-Struktur. Dabei wird in Bauteile und Knoten unterschieden. Ein Bauteil hat ein oder mehrere Knoten. Wobei Knoten miteinander verbunden werden können, und dann jeweils Informationen über angeschlossene Knoten enthalten. \autoref{img:circuitVerseNodes} verdeutlicht, wie CircuitVerse die Knoten verwendet. Die Grundlage für die Abbildung ist ein Grafikexport von CircuitVerse, wobei die Knotennummern zum besseren Verständnis der Funktionsweise besonders gekennzeichnet wurden. In \chphl{ \autoref{img:circuitVerseJson} \nameref{img:circuitVerseJson}}ist die zugehörige JSON-Datenstruktur abgebildet.
 \begin{figure}[H]
 	\begin{center}
 		\includegraphics[width=0.8\textwidth ,clip]{./images/circuitverseLogicJson.png}
 		\caption{Darstellung der JSON Datenstruktur}
 		\label{img:circuitVerseJson}
 	\end{center} 
 \end{figure}	
 
 \begin{figure}[H]
 	\begin{center}
 		\includegraphics[width=0.65\textwidth ,clip]{./images/circuitverseLogicNodes.pdf}
 		\caption{Logikschaltung mit gekennzeichneten Knoten}
 		\label{img:circuitVerseNodes}
 	\end{center} 
 \end{figure}	
 
 
 In der vorangehenden Abbildung \ref{img:circuitVerseNodes} ist zu sehen, dass jedes Bauteil einen oder mehrere Knoten Besitzt. In \autoref{img:circuitVerseJson} ist zu sehen, dass jeder dieser Knoten eine eigene Zeile unterhalb von \texttt{allNodes} besitzt. Hieraus geht hervor, mit welchen anderen Knoten er verbunden ist. Außerdem verbirgt sich im Feld \texttt{Typ}, die Information ob es sich um einen Ausgangsknoten einen Eingangsknoten oder einen Verbindungsknoten handelt. Ist der Knoten vom Typ Eingangknoten oder vom Typ Ausgangsknoten so gehört er einem Bauteil wie einem Logikgatter, einem Eingangsbausteinen oder einem Ausgangsbausteinen. Die Anordnung der Knoten ist logischer weise anders herum wie die der Bauteile, so besitzt ein Ausgangsbaustein genau einen Eingangsknoten (z.B.  \ref{img:circuitVerseNodes} Knoten 1), sowie ein Eingangsbaustein über einen Ausgangsknoten verfügt (z.B. \autoref{img:circuitVerseNodes} Knoten 9). Ein Gatter hingegen hat einen Ausgangsknoten sowie einen oder mehrere Eingangsknoten. (z.B. \autoref{img:circuitVerseNodes} Eingangssknoten 3,4 und Ausgangsknoten 4) Für die Umwandlung in Textform schien es am sinnvollsten an einem Ausgang anzusetzen und eine Wegfindung durchzuführen, welche beim Erreichen eines Eingangsbausteins einen Endpunkt hat. Dazu geht ein Rekursiver Algorithmus den Weg von einem Ausgangsknoten bis zu einem Eingangsknoten. Ist ein Eingangsknoten erreicht, so wird geprüft ob es sich um den Ausgang eines Eingangsbausteins handelt, oder um den Ausgang eines Logikgatters. Da CircuitVerse die Knoten jedoch nicht nach der Art des zugehörigen Bauteils, sondern nur in Eingangsknoten Ausgangsknoten oder Leitungsknoten unterteilt, muss die in \ref{img:circuitVerseJson} gezeigte Struktur oberhalb der Eigenschaft \texttt{allNodes} vorab durchlaufen werden. Hierbei wird ein Lookup Array angelegt (siehe \autoref{img:circuitVerseLookup}), welches die Bauteile mit der Knotennummer ihres Ausgangs indiziert. Bezogen auf das in \autoref{img:circuitVerseNodes} gezeigte Beispiel, würde für das AND-Gate ein Eintrag mit dem Index 4 angelegt. \autoref{img:circuitVerseLookup} Zeigt den Eintrag für dieses AND-Gate in der aufgeklappten Zeile mit dem Index vier. Das Array \texttt{nodesIn} beinhaltet die Knoten 2 und 3. An diesem Punkt, ruft die Funktion zur Wegfindung sich nun selbst auf. Auf diese weise werden sämtliche Logikgatter durchlaufen. In diesem Beispiel (siehe \autoref{img:circuitVerseNodes}) würde die Wegfindung von Knoten 2 über Knoten 5 auf Knoten 0 Treffen. Dieser ist jedoch kein Gateknoten sondern der Knoten eines Eingangsbausteines: Ein Endpunkt ist erreicht, das heißt es wird nun die Zeichenkette \texttt{[Hi0]} zurückgegeben. Zurück im vorher besprochenen AND-Gate, wird diese Zeichenkette nun mit dem Rückgabewert des Stranges an Knoten 3 und einem Kaufmännischen und (\&) verkettet. Da das And Gate genau zwei Eingangsknoten hat, sind nunmehr alle Knoten abgearbeitet und der Baustein gibt die Zeichenkette \texttt{[Hi0] \& ![Hi1]} zurück. Im Eingangsknoten wird diese Zeichenkette nun um den Bezeichner ergänzt.  Somit ergibt sich \texttt{[Tt0]=[Hi0] \& ![Hi1]} als Gesamtergebnis. 
  \begin{figure}[H]
 	\begin{center}
 		\includegraphics[width=0.65\textwidth ,clip]{./images/circuitverseLookup.png}
 		\caption{Lookup Array}
 		\label{img:circuitVerseLookup}
 	\end{center} 
 \end{figure}	
 
 
   \begin{figure}[H]
 	\begin{center}
 		\includegraphics[width=0.75\textwidth ,clip]{./images/PAP7.pdf}
 		\caption{Programm Ablaufplan}
 		\label{img:circuitVersePAP}
 	\end{center} 
 \end{figure}
 
 
 Der Algorithmus verarbeitet zuerst die in \ref{img:circuitVerseJson} gezeigte Eigenschaft \texttt{Outputs}, welche für jeden Ausgangsbaustein einen Eingangsknoten enthält. Bezogen auf das in \ref{img:circuitVerseNodes} gezeigte Beispiel, würde mit dem Ausgang \texttt{[Ho0]} und dem Zugehörigen Eingangsknoten \texttt{1} begonnen. In \autoref{img:circuitVerseJson} unter \texttt{AllNodes} ist dieser Knoten mit seiner Knotennummer \texttt{1} angelegt. Hierbei sind vor allem zwei Untereigenschaften genauer zu betrachten. Zum einen verrät die Eigenschaft \texttt{type}, ob es sich um einen Eingangsknoten (\texttt{1}), einen Ausgangsknoten \texttt{0} oder einen Leitungsknoten (\texttt{2}) handelt. Zum anderen bietet das Array \texttt{connections} am Ende der Zeile Aufschluss über die Verbundenen Knoten. Der Algorithmus würde nun, da es sich bei dem Knoten \texttt{1} um einen Ausgangsknoten (Typ 1) handelt, die in \texttt{connections} aufgeführten Knoten durchlaufen. 
 
  Zusätzlich muss festgehalten werden,  In der Regel reduziert sich die Anzahl der Anschließenden Knoten auf eins, sobald 
 
 Im zweiten Falle, wird im entsprechenden Logikgatter nach den Anschlussknoten der Eingänge gesucht, welche dann wiederum Rekursiv verfolgt werden, bis ein weiterer Eingangsknoten erreicht wird welcher vom Typ Eingangsbaustein ist. An jedem solchen Endpunkt, wird der Name des Eingangs als Zeichenkette zurückgegeben. Angenommen das vorgeschaltete Bauteil wäre ein Und-Gatter müsste dies nun nichts weiter tun muss als die beiden Teilergebnisse mittels \texttt{\&} zu verketten und die gesamte Zeichenkette als Gesamtergebnis zurückzugeben. Durch diese Vorgehensweise kann die Verschaltung beliebig komplex erfolgen. 




Die in \autoref{img:circuitVerseBasic} Abgebildete Logikschaltung, wird intern durch Knoten abgebildet. Ein Knoten ist entweder vom Typ Eingang, Ausgang oder Verbindung. 




\subsubsection{PHP Adapter Programme}

 
\clearpage
